/**
 * Generate /api/manage endpoint for the target framework
 */

import * as fs from 'fs';
import * as path from 'path';

export interface EndpointGenerationOptions {
  framework: 'django' | 'express' | 'supabase';
  outputDir: string;
  integration: string;
  kernelId: string;
  basePath?: string;  // Base path for endpoint (default: /api/manage)
}

export async function generateEndpoint(options: EndpointGenerationOptions): Promise<string> {
  const { framework, outputDir, integration, kernelId, basePath } = options;

  switch (framework) {
    case 'django':
      return await generateDjangoEndpoint(outputDir, integration, kernelId, basePath);
    case 'express':
      return await generateExpressEndpoint(outputDir, integration, kernelId, basePath);
    case 'supabase':
      return await generateSupabaseEndpoint(outputDir, integration, kernelId, basePath);
  }
}

async function generateDjangoEndpoint(outputDir: string, integration: string, kernelId: string, basePath?: string): Promise<string> {
  const viewsDir = path.join(outputDir, 'views');
  fs.mkdirSync(viewsDir, { recursive: true });

  const managePy = `"""
ACP ${basePath || '/api/manage'} endpoint view
Generated by Echelon installer
Phase 1: Critical Safety - Feature flag + lazy env reads
Phase 3: Graceful Degradation - Fail modes + read/write differentiation
"""

import json
import os
import logging

from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.views.decorators.http import require_http_methods

logger = logging.getLogger(__name__)

from control_plane.acp.router import create_manage_router
from control_plane.adapters import (
    DjangoDbAdapter, DjangoAuditAdapter,
    DjangoIdempotencyAdapter, DjangoRateLimitAdapter, DjangoCeilingsAdapter
)
from control_plane.packs.your_domain import your_domain_pack
from control_plane.bindings import get_bindings

# Optional: Repo B/C adapters
from control_plane.control_plane_adapter import HttpControlPlaneAdapter
from control_plane.executor_adapter import HttpExecutorAdapter
from control_plane.repo_b_audit_adapter import RepoBAuditAdapter

# Phase 1: No import-time env reads - all initialization is lazy
_router = None
_control_plane = None

def _get_router():
    """
    Lazy router initialization - all env reads happen here, not at module import.
    This prevents startup failures if env vars are missing.
    """
    global _router, _control_plane
    if _router is None:
        # All env reads happen inside this function (lazy initialization)
        bindings = get_bindings()
        
        # Create Repo C executor adapter (optional) - env read inside handler
        executor = None
        cia_url = os.environ.get('CIA_URL')
        cia_service_key = os.environ.get('CIA_SERVICE_KEY')
        if cia_url and cia_service_key:
            executor = HttpExecutorAdapter(
                cia_url=cia_url,
                cia_service_key=cia_service_key,
                cia_anon_key=os.environ.get('CIA_ANON_KEY'),
                kernel_id=bindings['kernelId'],
            )
        
        # Create Repo B control plane adapter (optional) - env read inside handler
        # Support both ACP_BASE_URL (new standard) and GOVERNANCE_HUB_URL (legacy)
        governance_url = os.environ.get('ACP_BASE_URL') or os.environ.get('GOVERNANCE_HUB_URL')
        kernel_api_key = os.environ.get('ACP_KERNEL_KEY')
        if governance_url and kernel_api_key:
            _control_plane = HttpControlPlaneAdapter(
                platform_url=governance_url,
                kernel_api_key=kernel_api_key,
            )
            # Send heartbeat on first request (not on module import)
            try:
                kernel_id = os.environ.get('KERNEL_ID', bindings['kernelId'])
                result = _control_plane.heartbeat(
                    kernel_id=kernel_id,
                    version='1.0.0',
                    packs=['your_domain'],
                    env=os.environ.get('ENVIRONMENT', 'production')
                )
                if result.get('ok'):
                    print(f"✅ Kernel registered with Repo B: {kernel_id}")
                else:
                    print(f"⚠️ Heartbeat failed: {result.get('error')}")
            except Exception as e:
                print(f"⚠️ Heartbeat error (non-fatal): {e}")
        
        # Create audit adapter (Repo B if configured, otherwise local)
        if governance_url and kernel_api_key:
            audit_adapter = RepoBAuditAdapter(
                governance_url=governance_url,
                kernel_id=bindings['kernelId'],
                kernel_api_key=kernel_api_key,
            )
        else:
            audit_adapter = DjangoAuditAdapter()
        
        _router = create_manage_router(
            audit_adapter=audit_adapter,
            idempotency_adapter=DjangoIdempotencyAdapter(),
            rate_limit_adapter=DjangoRateLimitAdapter(),
            ceilings_adapter=DjangoCeilingsAdapter(),
            bindings=bindings,
            packs=[your_domain_pack],
            executor=executor,
            control_plane=_control_plane,
        )
    return _router

def is_read_action(action: str) -> bool:
    """
    Phase 3: Detect if an action is a read operation.
    Read actions can be allowed in fail-open or read-open modes.
    """
    read_prefixes = ['meta.', 'list', 'get', 'read', 'query', 'search', 'fetch']
    action_lower = action.lower()
    return any(action_lower.startswith(prefix) for prefix in read_prefixes)

def get_fail_mode() -> str:
    """
    Phase 3: Get failure mode from environment.
    Options: 'open' (default), 'closed', 'read-open'
    """
    return os.environ.get('ACP_FAIL_MODE', 'open').lower()

def handle_governance_failure(action: str, error: Exception) -> dict:
    """
    Phase 3: Handle governance hub (Repo B) failures based on fail mode.
    Returns error response or None if should continue.
    """
    fail_mode = get_fail_mode()
    error_msg = str(error) if error else "Unknown error"
    
    # Better error messages
    error_messages = {
        'governance_unreachable': "Governance hub (Repo B) is unreachable. Check ACP_BASE_URL and network connectivity.",
        'governance_required': "This action requires governance hub (Repo B) to be available.",
        'local_mode': "Operating in local-only mode (governance hub unreachable). Some features may be limited.",
    }
    
    logger.warning(f"Governance hub error: {error_msg}")
    
    # Fail-open: Allow all actions if Repo B unreachable
    if fail_mode == 'open':
        logger.warning(f"Fail-open mode: Allowing action '{action}' despite governance hub failure")
        logger.info(error_messages['local_mode'])
        return None  # Continue with local-only mode
    
    # Fail-closed: Deny all actions if Repo B unreachable
    elif fail_mode == 'closed':
        logger.error(f"Fail-closed mode: Denying action '{action}' due to governance hub failure")
        return {
            "ok": False,
            "error": error_messages['governance_unreachable'],
            "code": "GOVERNANCE_UNAVAILABLE",
            "details": f"Governance hub error: {error_msg}"
        }
    
    # Read-open: Allow reads, require Repo B for writes
    elif fail_mode == 'read-open':
        if is_read_action(action):
            logger.warning(f"Read-open mode: Allowing read action '{action}' despite governance hub failure")
            logger.info(error_messages['local_mode'])
            return None  # Continue for read actions
        else:
            logger.error(f"Read-open mode: Denying write action '{action}' - governance hub required")
            return {
                "ok": False,
                "error": error_messages['governance_required'],
                "code": "GOVERNANCE_UNAVAILABLE",
                "details": f"Write actions require governance hub. Error: {error_msg}"
            }
    
    # Default: fail-open (safe default)
    else:
        logger.warning(f"Unknown fail mode '{fail_mode}', defaulting to fail-open")
        return None

@csrf_exempt
@require_http_methods(["POST"])
def manage_endpoint(request):
    """POST ${basePath || '/api/manage'} - Agentic control plane"""
    # Phase 1: Feature flag check (first thing, before any processing)
    acp_enabled = os.environ.get('ACP_ENABLED', 'false').lower() == 'true'
    if not acp_enabled:
        return JsonResponse(
            {
                "ok": False,
                "error": "ACP is disabled. Set ACP_ENABLED=true to enable.",
                "code": "FEATURE_DISABLED"
            },
            status=503,
        )
    
    try:
        body = json.loads(request.body) if request.body else {}
    except json.JSONDecodeError:
        return JsonResponse(
            {"ok": False, "error": "Invalid JSON", "code": "VALIDATION_ERROR"},
            status=400,
        )
    
    action = body.get('action', '')
    meta = {
        "request": request,
        "ip_address": get_client_ip(request),
        "user_agent": request.META.get("HTTP_USER_AGENT", ""),
    }
    
    # Lazy router initialization (all env reads happen here)
    router = _get_router()
    
    # Phase 3: Execute with exception handling around Repo B calls
    try:
        response = router(body, meta)
        
        # Phase 3: Check response for governance-related errors
        if not response.get("ok"):
            error_code = response.get("code", "")
            error_msg = response.get("error", "")
            error_lower = error_msg.lower()
            
            # Check if this is a governance hub error
            is_governance_error = (
                "GOVERNANCE_UNAVAILABLE" in error_code or
                "governance" in error_lower or
                "repo b" in error_lower or
                "authorization" in error_lower and "unreachable" in error_lower
            )
            
            if is_governance_error:
                # Phase 3: Handle governance hub failure based on fail mode
                failure_response = handle_governance_failure(action, Exception(error_msg))
                if failure_response:
                    # Fail-closed or read-open denying write: return the failure response
                    return JsonResponse(failure_response, status=503)
                else:
                    # Fail-open or read-open allowing: continue with local mode
                    logger.info("Governance hub error, but continuing in local mode per fail mode setting")
                    # Modify response to indicate local mode
                    response["warning"] = "Operating in local-only mode (governance hub unreachable)"
                    response["ok"] = True  # Override to allow in local mode
                    
    except Exception as e:
        # Phase 3: Check if this is a governance hub error from exception
        error_str = str(e).lower()
        is_governance_error = (
            'governance' in error_str or 
            'repo b' in error_str or 
            ('authorization' in error_str and 'unreachable' in error_str) or
            'timeout' in error_str or
            'connection' in error_str
        )
        
        if is_governance_error:
            # Phase 3: Handle governance hub failure based on fail mode
            failure_response = handle_governance_failure(action, e)
            if failure_response:
                return JsonResponse(failure_response, status=503)
            else:
                # Fail-open or read-open allowing: return local mode response
                logger.warning(f"Governance hub exception, but continuing due to fail mode: {get_fail_mode()}")
                return JsonResponse(
                    {
                        "ok": True,
                        "data": {},
                        "warning": "Operating in local-only mode (governance hub unreachable)",
                        "code": "LOCAL_MODE"
                    },
                    status=200,
                )
        else:
            # Non-governance error, return as-is
            logger.error(f"Non-governance error in router: {e}")
            return JsonResponse(
                {
                    "ok": False,
                    "error": f"Internal server error: {str(e)}",
                    "code": "INTERNAL_ERROR"
                },
                status=500,
            )
    
    status = 200
    if not response.get("ok"):
        code = response.get("code", "INTERNAL_ERROR")
        status_map = {
            "INVALID_API_KEY": 401,
            "SCOPE_DENIED": 403,
            "NOT_FOUND": 404,
            "RATE_LIMITED": 429,
            "VALIDATION_ERROR": 400,
            "FEATURE_DISABLED": 503,
            "GOVERNANCE_UNAVAILABLE": 503,
        }
        status = status_map.get(code, 500)
    
    return JsonResponse(response, status=status)

def get_client_ip(request):
    xff = request.META.get("HTTP_X_FORWARDED_FOR")
    if xff:
        return xff.split(",")[0].strip()
    return request.META.get("REMOTE_ADDR", "")
`;

  const filePath = path.join(viewsDir, 'manage.py');
  fs.writeFileSync(filePath, managePy);
  return filePath;
}

async function generateExpressEndpoint(outputDir: string, integration: string, kernelId: string): Promise<string> {
  const apiDir = path.join(outputDir, 'api');
  fs.mkdirSync(apiDir, { recursive: true });

  const manageTs = `/**
 * ACP /manage endpoint
 * Generated by Echelon installer
 */

import { createManageRouter } from '../control_plane/kernel';
import { iamPack, webhooksPack, settingsPack } from '../control_plane/packs';
import { createAdapters } from '../control_plane/adapters';
import bindings from '../controlplane.bindings.json';

const router = createManageRouter({
  ...createAdapters(),
  bindings,
  packs: [iamPack, webhooksPack, settingsPack, yourDomainPack]
});

export default async function handler(req: any, res: any) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    const body = req.body;
    const response = await router(body, {
      request: req,
      ipAddress: req.ip || req.headers['x-forwarded-for'],
      userAgent: req.headers['user-agent']
    });

    res.status(response.status || 200).json(JSON.parse(response.body));
  } catch (error) {
    res.status(500).json({ error: 'Internal server error' });
  }
}
`;

  const filePath = path.join(apiDir, 'manage.ts');
  fs.writeFileSync(filePath, manageTs);
  return filePath;
}

async function generateSupabaseEndpoint(outputDir: string, integration: string, kernelId: string): Promise<string> {
  const functionsDir = path.join(outputDir, 'supabase', 'functions', 'manage');
  fs.mkdirSync(functionsDir, { recursive: true });

  const indexTs = `/**
 * Supabase Edge Function: /manage endpoint
 * Generated by Echelon installer
 */

import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createManageRouter } from '../../control_plane/kernel';
import { iamPack, webhooksPack, settingsPack } from '../../control_plane/packs';
import { createAdapters } from '../../control_plane/adapters';
import bindings from '../../controlplane.bindings.json';

const router = createManageRouter({
  ...createAdapters(),
  bindings,
  packs: [iamPack, webhooksPack, settingsPack, yourDomainPack]
});

serve(async (req) => {
  if (req.method !== 'POST') {
    return new Response(JSON.stringify({ error: 'Method not allowed' }), {
      status: 405,
      headers: { 'Content-Type': 'application/json' }
    });
  }

  try {
    const body = await req.json();
    const response = await router(body, {
      request: req,
      ipAddress: req.headers.get('x-forwarded-for') || 'unknown',
      userAgent: req.headers.get('user-agent') || 'unknown'
    });

    return new Response(response.body, {
      status: response.status || 200,
      headers: { 'Content-Type': 'application/json', ...response.headers }
    });
  } catch (error) {
    return new Response(JSON.stringify({ error: 'Internal server error' }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
});
`;

  const filePath = path.join(functionsDir, 'index.ts');
  fs.writeFileSync(filePath, indexTs);
  return filePath;
}
