/**
 * Generate /api/manage endpoint for the target framework
 */

import * as fs from 'fs';
import * as path from 'path';

export interface EndpointGenerationOptions {
  framework: 'django' | 'express' | 'supabase';
  outputDir: string;
  integration: string;
  kernelId: string;
}

export async function generateEndpoint(options: EndpointGenerationOptions): Promise<string> {
  const { framework, outputDir, integration, kernelId } = options;

  switch (framework) {
    case 'django':
      return await generateDjangoEndpoint(outputDir, integration, kernelId);
    case 'express':
      return await generateExpressEndpoint(outputDir, integration, kernelId);
    case 'supabase':
      return await generateSupabaseEndpoint(outputDir, integration, kernelId);
  }
}

async function generateDjangoEndpoint(outputDir: string, integration: string, kernelId: string): Promise<string> {
  const viewsDir = path.join(outputDir, 'views');
  fs.mkdirSync(viewsDir, { recursive: true });

  const managePy = `"""
ACP /manage endpoint view
Generated by Echelon installer
"""

import json
import os

from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.views.decorators.http import require_http_methods

from control_plane.acp.router import create_manage_router
from control_plane.adapters import (
    DjangoDbAdapter, DjangoAuditAdapter,
    DjangoIdempotencyAdapter, DjangoRateLimitAdapter, DjangoCeilingsAdapter
)
from control_plane.packs.your_domain import your_domain_pack
from control_plane.bindings import get_bindings

# Optional: Repo B/C adapters
from control_plane.control_plane_adapter import HttpControlPlaneAdapter
from control_plane.executor_adapter import HttpExecutorAdapter
from control_plane.repo_b_audit_adapter import RepoBAuditAdapter

_router = None

def _get_router():
    global _router
    if _router is None:
        bindings = get_bindings()
        
        # Create Repo C executor adapter (optional)
        executor = None
        if os.environ.get('CIA_URL') and os.environ.get('CIA_SERVICE_KEY'):
            executor = HttpExecutorAdapter(
                cia_url=os.environ.get('CIA_URL'),
                cia_service_key=os.environ.get('CIA_SERVICE_KEY'),
                cia_anon_key=os.environ.get('CIA_ANON_KEY'),
                kernel_id=bindings['kernelId'],
            )
        
        # Create Repo B control plane adapter (optional)
        control_plane = None
        if os.environ.get('GOVERNANCE_HUB_URL') and os.environ.get('ACP_KERNEL_KEY'):
            control_plane = HttpControlPlaneAdapter(
                platform_url=os.environ.get('GOVERNANCE_HUB_URL'),
                kernel_api_key=os.environ.get('ACP_KERNEL_KEY'),
            )
        
        # Create audit adapter (Repo B if configured, otherwise local)
        if os.environ.get('GOVERNANCE_HUB_URL') and os.environ.get('ACP_KERNEL_KEY'):
            audit_adapter = RepoBAuditAdapter(
                governance_url=os.environ.get('GOVERNANCE_HUB_URL'),
                kernel_id=bindings['kernelId'],
                kernel_api_key=os.environ.get('ACP_KERNEL_KEY'),
            )
        else:
            audit_adapter = DjangoAuditAdapter()
        
        _router = create_manage_router(
            audit_adapter=audit_adapter,
            idempotency_adapter=DjangoIdempotencyAdapter(),
            rate_limit_adapter=DjangoRateLimitAdapter(),
            ceilings_adapter=DjangoCeilingsAdapter(),
            bindings=bindings,
            packs=[your_domain_pack],
            executor=executor,
            control_plane=control_plane,
        )
    return _router

@csrf_exempt
@require_http_methods(["POST"])
def manage_endpoint(request):
    """POST /api/manage - Agentic control plane"""
    try:
        body = json.loads(request.body) if request.body else {}
    except json.JSONDecodeError:
        return JsonResponse(
            {"ok": False, "error": "Invalid JSON", "code": "VALIDATION_ERROR"},
            status=400,
        )
    
    meta = {
        "request": request,
        "ip_address": get_client_ip(request),
        "user_agent": request.META.get("HTTP_USER_AGENT", ""),
    }
    
    router = _get_router()
    response = router(body, meta)
    
    status = 200
    if not response.get("ok"):
        code = response.get("code", "INTERNAL_ERROR")
        status_map = {
            "INVALID_API_KEY": 401,
            "SCOPE_DENIED": 403,
            "NOT_FOUND": 404,
            "RATE_LIMITED": 429,
            "VALIDATION_ERROR": 400,
        }
        status = status_map.get(code, 500)
    
    return JsonResponse(response, status=status)

def get_client_ip(request):
    xff = request.META.get("HTTP_X_FORWARDED_FOR")
    if xff:
        return xff.split(",")[0].strip()
    return request.META.get("REMOTE_ADDR", "")
`;

  const filePath = path.join(viewsDir, 'manage.py');
  fs.writeFileSync(filePath, managePy);
  return filePath;
}

async function generateExpressEndpoint(outputDir: string, integration: string, kernelId: string): Promise<string> {
  const apiDir = path.join(outputDir, 'api');
  fs.mkdirSync(apiDir, { recursive: true });

  const manageTs = `/**
 * ACP /manage endpoint
 * Generated by Echelon installer
 */

import { createManageRouter } from '../control_plane/kernel';
import { iamPack, webhooksPack, settingsPack } from '../control_plane/packs';
import { createAdapters } from '../control_plane/adapters';
import bindings from '../controlplane.bindings.json';

const router = createManageRouter({
  ...createAdapters(),
  bindings,
  packs: [iamPack, webhooksPack, settingsPack, yourDomainPack]
});

export default async function handler(req: any, res: any) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    const body = req.body;
    const response = await router(body, {
      request: req,
      ipAddress: req.ip || req.headers['x-forwarded-for'],
      userAgent: req.headers['user-agent']
    });

    res.status(response.status || 200).json(JSON.parse(response.body));
  } catch (error) {
    res.status(500).json({ error: 'Internal server error' });
  }
}
`;

  const filePath = path.join(apiDir, 'manage.ts');
  fs.writeFileSync(filePath, manageTs);
  return filePath;
}

async function generateSupabaseEndpoint(outputDir: string, integration: string, kernelId: string): Promise<string> {
  const functionsDir = path.join(outputDir, 'supabase', 'functions', 'manage');
  fs.mkdirSync(functionsDir, { recursive: true });

  const indexTs = `/**
 * Supabase Edge Function: /manage endpoint
 * Generated by Echelon installer
 */

import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createManageRouter } from '../../control_plane/kernel';
import { iamPack, webhooksPack, settingsPack } from '../../control_plane/packs';
import { createAdapters } from '../../control_plane/adapters';
import bindings from '../../controlplane.bindings.json';

const router = createManageRouter({
  ...createAdapters(),
  bindings,
  packs: [iamPack, webhooksPack, settingsPack, yourDomainPack]
});

serve(async (req) => {
  if (req.method !== 'POST') {
    return new Response(JSON.stringify({ error: 'Method not allowed' }), {
      status: 405,
      headers: { 'Content-Type': 'application/json' }
    });
  }

  try {
    const body = await req.json();
    const response = await router(body, {
      request: req,
      ipAddress: req.headers.get('x-forwarded-for') || 'unknown',
      userAgent: req.headers.get('user-agent') || 'unknown'
    });

    return new Response(response.body, {
      status: response.status || 200,
      headers: { 'Content-Type': 'application/json', ...response.headers }
    });
  } catch (error) {
    return new Response(JSON.stringify({ error: 'Internal server error' }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
});
`;

  const filePath = path.join(functionsDir, 'index.ts');
  fs.writeFileSync(filePath, indexTs);
  return filePath;
}
