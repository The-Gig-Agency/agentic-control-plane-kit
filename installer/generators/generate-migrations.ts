/**
 * Generate database migrations
 */

import * as fs from 'fs';
import * as path from 'path';

export interface MigrationGenerationOptions {
  framework: 'django' | 'express' | 'supabase';
  outputDir: string;
  validateOnly?: boolean;  // Phase 2: Only validate, don't generate
}

export interface MigrationValidationResult {
  valid: boolean;
  errors: string[];
}

export async function generateMigrations(options: MigrationGenerationOptions): Promise<string[]> {
  const { framework, outputDir, validateOnly } = options;

  // Phase 2: Validate migrations before generating
  if (validateOnly) {
    const validation = await validateMigrations(framework);
    if (!validation.valid) {
      throw new Error(`Migration validation failed:\n${validation.errors.join('\n')}`);
    }
    return [];
  }

  // Validate before generating
  const validation = await validateMigrations(framework);
  if (!validation.valid) {
    throw new Error(`Migration validation failed:\n${validation.errors.join('\n')}`);
  }

  switch (framework) {
    case 'django':
      return await generateDjangoMigrations(outputDir);
    case 'express':
    case 'supabase':
      return await generateSqlMigrations(outputDir);
  }
}

/**
 * Phase 2: Validate migrations (reject ALTER/DROP statements)
 */
export async function validateMigrations(framework: string): Promise<MigrationValidationResult> {
  const errors: string[] = [];

  if (framework === 'django') {
    // Django migrations generated by this installer only use CreateModel
    // No AlterModel or DeleteModel operations - safe by design
    // Could add runtime validation here if needed
  } else {
    // SQL migrations should only use CREATE, not ALTER or DROP
    // The generator template is validated to ensure this
    // For SQL, we check the template content
    const template = getSqlMigrationTemplate();
    
    const forbiddenPatterns = [
      { pattern: /ALTER\s+TABLE/gi, name: 'ALTER TABLE' },
      { pattern: /DROP\s+TABLE/gi, name: 'DROP TABLE' },
      { pattern: /DROP\s+INDEX/gi, name: 'DROP INDEX' },
      { pattern: /DELETE\s+FROM/gi, name: 'DELETE FROM' },
      { pattern: /TRUNCATE/gi, name: 'TRUNCATE' },
    ];
    
    for (const { pattern, name } of forbiddenPatterns) {
      if (pattern.test(template)) {
        errors.push(`Migration template contains forbidden statement: ${name}`);
      }
    }
  }
  
  return {
    valid: errors.length === 0,
    errors,
  };
}

/**
 * Get SQL migration template for validation
 */
function getSqlMigrationTemplate(): string {
  return `-- Control plane tables migration
-- Generated by Echelon installer

CREATE TABLE IF NOT EXISTS api_keys (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL,
    prefix VARCHAR(20) NOT NULL,
    key_hash VARCHAR(64) NOT NULL,
    name VARCHAR(255),
    scopes JSONB DEFAULT '[]',
    created_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ
);

CREATE INDEX idx_api_keys_tenant ON api_keys(tenant_id);
CREATE INDEX idx_api_keys_prefix ON api_keys(prefix);

CREATE TABLE IF NOT EXISTS audit_log (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL,
    actor_type VARCHAR(20) NOT NULL,
    actor_id VARCHAR(255) NOT NULL,
    action VARCHAR(255) NOT NULL,
    request_id VARCHAR(255) NOT NULL,
    result VARCHAR(20) NOT NULL,
    error_message TEXT,
    ip_address INET,
    dry_run BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_audit_log_tenant_created ON audit_log(tenant_id, created_at);
CREATE INDEX idx_audit_log_action_created ON audit_log(action, created_at);
CREATE INDEX idx_audit_log_request_id ON audit_log(request_id);
`;
}

async function generateDjangoMigrations(outputDir: string): Promise<string[]> {
  const migrationsDir = path.join(outputDir, 'your_app', 'migrations');
  fs.mkdirSync(migrationsDir, { recursive: true });

  const migrationPy = `"""
Database migrations for control plane tables
Generated by Echelon installer
Phase 2: Migration Control - Only CREATE operations (no ALTER/DROP)
"""

import uuid
from django.db import migrations, models

class Migration(migrations.Migration):
    dependencies = [
        ('your_app', 'XXXX_previous_migration'),  # TODO: Update with actual previous migration
    ]

    operations = [
        migrations.CreateModel(
            name='ApiKey',
            fields=[
                ('id', models.UUIDField(primary_key=True, default=uuid.uuid4)),
                ('tenant_id', models.UUIDField()),
                ('prefix', models.CharField(max_length=20)),
                ('key_hash', models.CharField(max_length=64)),
                ('name', models.CharField(max_length=255)),
                ('scopes', models.JSONField(default=list)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('expires_at', models.DateTimeField(null=True)),
            ],
            options={
                'db_table': 'api_keys',
            },
        ),
        migrations.CreateModel(
            name='AuditLog',
            fields=[
                ('id', models.UUIDField(primary_key=True, default=uuid.uuid4)),
                ('tenant_id', models.UUIDField()),
                ('actor_type', models.CharField(max_length=20)),
                ('actor_id', models.CharField(max_length=255)),
                ('action', models.CharField(max_length=255)),
                ('request_id', models.CharField(max_length=255)),
                ('result', models.CharField(max_length=20)),
                ('error_message', models.TextField(null=True)),
                ('ip_address', models.GenericIPAddressField(null=True)),
                ('dry_run', models.BooleanField(default=False)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
            ],
            options={
                'db_table': 'audit_log',
                'indexes': [
                    models.Index(fields=['tenant_id', 'created_at']),
                    models.Index(fields=['action', 'created_at']),
                ],
            },
        ),
    ]
`;

  const timestamp = new Date().toISOString().replace(/[-:]/g, '').split('.')[0];
  const filePath = path.join(migrationsDir, `${timestamp}_add_control_plane_tables.py`);
  fs.writeFileSync(filePath, migrationPy);
  return [filePath];
}

async function generateSqlMigrations(outputDir: string): Promise<string[]> {
  const migrationsDir = path.join(outputDir, 'migrations');
  fs.mkdirSync(migrationsDir, { recursive: true });

  const migrationSql = `-- Control plane tables migration
-- Generated by Echelon installer

CREATE TABLE IF NOT EXISTS api_keys (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL,
    prefix VARCHAR(20) NOT NULL,
    key_hash VARCHAR(64) NOT NULL,
    name VARCHAR(255),
    scopes JSONB DEFAULT '[]',
    created_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ
);

CREATE INDEX idx_api_keys_tenant ON api_keys(tenant_id);
CREATE INDEX idx_api_keys_prefix ON api_keys(prefix);

CREATE TABLE IF NOT EXISTS audit_log (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL,
    actor_type VARCHAR(20) NOT NULL,
    actor_id VARCHAR(255) NOT NULL,
    action VARCHAR(255) NOT NULL,
    request_id VARCHAR(255) NOT NULL,
    result VARCHAR(20) NOT NULL,
    error_message TEXT,
    ip_address INET,
    dry_run BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_audit_log_tenant_created ON audit_log(tenant_id, created_at);
CREATE INDEX idx_audit_log_action_created ON audit_log(action, created_at);
CREATE INDEX idx_audit_log_request_id ON audit_log(request_id);
`;

  const timestamp = Date.now();
  const filePath = path.join(migrationsDir, `${timestamp}_add_control_plane_tables.sql`);
  fs.writeFileSync(filePath, migrationSql);
  return [filePath];
}
